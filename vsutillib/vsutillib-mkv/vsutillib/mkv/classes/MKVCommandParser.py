"""

 Parse mkvmerge into a class

Track options assumed appear after --language

r"|--sync "
r"|--cues "
r"|--default-track "
r"|--forced-track "
r"|--blockadd "
r"|--track-name "
r"|--tags "
r"|--aac-is-sbr "
r"|--reduce-to-core "
r"|--remove-dialog-normalization-gain  "
r"|--timestamps "
r"|--default-duration "
r"|--fix-bitstream-timing-information "
r"|--nalu-size-length "
r"|--compression "


Properties update

<MKVPROPEDIT.EXE> <SOURCE> --edit info --set title=<TITLE>

Flow:

1. Receive command.
2. initialize variables
3. save command in internal variable self.__strCommand
4. remove title from command we want to preserve what title is set by file
    - Temp OUT:
5. convert to bash style easier to parse
6. start parsing self._parse()
    - prepare regular expressions
    - first regEx for the whole command to see if general structure is sound
    Look for:
        - mkvmerge executable
        - output file
        - first source must have at least one
        - track order checking for sound list of tracks
        - check for one track file and set self.cliTrackOrder to None if True
    - second regEx language used in the command line for to english for now
        - Temp OUT:
    - create template with function commandTemplate()
        - substitute keys in command
            - <OUTPUTFILE> for the output file name
            - <SOURCE0> .. <SOURCEN> for the source files
            - <TITLE> for file title if given
            - <CHAPTERS> for chapters file if given
            - <ATTACHMENTS> attachments if given
            - <ORDER> for the track order if case of adjustments by file
    - from commandTemplate resolve executable file and save it in self.mkvmerge and
    also set self.mkvpropedit
    - from commandTemplate resolve the output file directory
    - from commandTemplate resolve the source files
        - create SourceFile object for everyone and save each one in the
        self.oSourceFiles (SourceFiles()) object
        - set the total number of files when reading the total of files for the
        first source file.  Any other source must match this number.  Create the
        list for all the output files.
        - set the total for list self.cliTrackOrder create list for all commands
        in case needed for adjustment
        - works with self.dirsByKey and self.filesByKey this means that the
        directory for every source dirsByKey and every file filesByKey are saved
        the keys are <OUTPUTFILE> and <SOURCE0> ... <SOURCEN>. Collision with
        the output file are solved for no overwrite
    - from commandTemplate resolve chapter file in command line

7. if no error in parsing set self.translations for any adjustments later
8. set self.__readFiles to True
9. read the files self.readFiles() this is here for testing purposes if user
corrects a problem the test functions can re-read the files.
    - self._readDirs()
        - setup attachments from oAttachments update for commandTemplate the
        program will test if the attachment are in a directory that have a
        subdirectory for every source file
        - titles are read for every file code is here for future use now it
        read from the files but it will read from the internet eventually
        - read the chapter files into a list
    - self._filesInDirByKey()
        - fill the attachment, titles and chapters file by key
10. generate the commands self.generateCommands()
"""
# MCP0003

import ast
import logging
import re
import shlex

from pathlib import Path
from typing import Optional

from natsort import natsorted, ns

# from vsutillib.media import MediaFileInfo

from ..generateCommandTemplate import generateCommandTemplate
from ..mkvutils import (
    convertToBashStyle,
    generateCommand,
    getMKVMerge,
    getMKVMergeEmbedded,
    numberOfTracksInCommand,
    resolveOverwrite,
    setEncaseQuotes,
    stripEncaseQuotes,
    unQuote,
)

from .SourceFiles import SourceFile, SourceFiles
from .MKVAttachments import MKVAttachments
from .MKVParseKey import MKVParseKey


MODULELOG = logging.getLogger(__name__)
MODULELOG.addHandler(logging.NullHandler())


class MKVCommandParser:
    """
    Class for parsing CLI **mkvmerge** command part of MKVToolnix_

    Args:
        strCommand (`str`, optional): command line as generated by mkvtoolnix-gui
    """

    __log = False

    # embedded
    rgMkvmerge = r"^(.*?)\s--.*"
    reMkvMergeEx = re.compile(rgMkvmerge)

    def __init__(
            self,
            strCommand: Optional[str] = None,
            appDir: Optional[Path] = None,
            useEmbedded:  Optional[bool] = False,
            preserveTrackNames: Optional[bool] = None,
            log: Optional[bool] = None
        ) -> None:

        self.log = log
        self.__useEmbedded = useEmbedded
        self.__mkvmergeEmbedded = None
        if appDir is not None:
            self.__mkvmergeEmbedded = getMKVMergeEmbedded(appDir)
        self.__mkvmergeSystem = getMKVMerge()
        self.command = strCommand
        if preserveTrackNames is not None:
            self.preserveTrackNames = preserveTrackNames

    def _initVars(self) -> None:
        self.__bashCommand = None
        self.__embeddedBashCommand = None
        self.__errorFound = False
        self.__log = None
        self.__lstAnalysis = None
        self.__totalSourceFiles = None
        self.__readFiles = False
        self.__strCommand = None
        self.__shellCommands = []
        self.__strCommands = []
        # self.__strOCommands = []
        self.__setTitles = True
        self.__preserveTrackNames = False

        self.cliChaptersFile = None
        self.commandTemplate = None
        self.originalCommandTemplate = None
        self.mkvmerge = None
        self.mkvpropedit = None
        self.cliOutputFile = None
        # self.cliOutputFileMatchString = None
        # self.cliTitleMatchString = None
        self.cliTracksOrder = None

        self.commandTemplates = []
        self.tracksOrder = []
        self.translations = None
        self.chaptersFiles = []
        self.filesInDirByKey = {}
        self.dirsByKey = {}
        self.titles = []
        self.newNames = []

        self.oAttachments = MKVAttachments()
        self.oSourceFiles = SourceFiles()

    def __bool__(self) -> bool:
        return not self.__errorFound

    def __contains__(self, item) -> bool:
        return item in self.__strCommands

    def __getitem__(self, index):
        return (
            self.__shellCommands[index],
            self.baseFiles,
            self.oSourceFiles[index],
            self.filesInDirByKey[MKVParseKey.outputFile][index],
            None if not self.oAttachments else self.oAttachments.attachmentsStr[index],
            None if not self.titles else self.titles[index],
            None if not self.cliChaptersFile else self.chaptersFiles[index],
        )

    def __len__(self) -> int:
        return self.__totalSourceFiles

    def __str__(self) -> str:
        return self.__strCommand

    @classmethod
    def classLog(cls, setLogging: Optional[bool] = None) -> bool:
        """
        get/set logging at class level
        every class instance will log
        unless overwritten

        Args:
            setLogging (bool):
                - True class will log
                - False turn off logging
                - None returns current Value

        Returns:
            bool:

            returns the current value set
        """

        if setLogging is not None:
            if isinstance(setLogging, bool):
                cls.__log = setLogging

        return cls.__log

    @property
    def log(self) -> bool:
        """
        class property can be used to override the class global
        logging setting

            bool:

            True if logging is enable False otherwise
        """
        if self.__log is not None:
            return self.__log

        return MKVCommandParser.classLog()

    @log.setter
    def log(self, value: bool) -> None:
        """set instance log variable"""
        if isinstance(value, bool) or value is None:
            self.__log = value

    @property
    def analysis(self):
        """
        results of analysis of the command

        Returns:
            list:

            list with comments of anything found
        """

        return self.__lstAnalysis

    @property
    def baseFiles(self):
        lstTmp = []
        lstTmp = [x.fileName for x in self.oSourceFiles.sourceFiles]

        return lstTmp

    @property
    def bashCommand(self):
        return self.__bashCommand

    @property
    def command(self):
        return self.__strCommand

    @command.setter
    def command(self, value):
        if isinstance(value, str):
            self._initVars()
            self.__strCommand = value

            if self.__strCommand:
                strCommand = convertToBashStyle(self.__strCommand)
                self.__bashCommand = strCommand
                self.__embeddedBashCommand = embeddedBashCommand(
                    strCommand,
                    self.__mkvmergeEmbedded)
                self._parse()
                if not self.__errorFound:
                    self.translations = [None] * self.__totalSourceFiles
                self.__readFiles = True
                self.readFiles()
                self.generateCommands()

    @property
    def commandsGenerated(self):
        return not self.__readFiles

    @property
    def destinationFiles(self):
        """
        destination files

        Returns:
            list:

            list with destination files
        """

        if MKVParseKey.outputFile in self.filesInDirByKey:
            return self.filesInDirByKey[MKVParseKey.outputFile]

        return []

    @property
    def embeddedBashCommand(self):
        return self.__embeddedBashCommand

    @property
    def oBaseFiles(self):
        return self.oSourceFiles.sourceFiles

    @property
    def outputFileExtension(self):
        if isinstance(self.cliOutputFile, Path):
            return self.cliOutputFile.suffix
        return None

    @property
    def preserveTrackNames(self):
        return bool(self.__preserveTrackNames)

    @preserveTrackNames.setter
    def preserveTrackNames(self, value):
        if isinstance(value, bool):
            self.__preserveTrackNames = value

    @property
    def mkvmergeSystem(self):
        return self.__mkvmergeSystem

    @mkvmergeSystem.setter
    def mkvmergeSystem(self, value):
        if isinstance(value, Path):
            self.__mkvmergeSystem = value

    @property
    def mkvmergeEmbedded(self):
        return self.__mkvmergeEmbedded

    @mkvmergeEmbedded.setter
    def mkvmergeEmbedded(self, value):
        if isinstance(value, Path):
            self.__mkvmergeEmbedded = value

    @property
    def strCommands(self):
        return self.__strCommands

    @property
    def shellCommands(self):
        return self.__shellCommands

    @property
    def useEmbedded(self):
        return self.__useEmbedded

    @useEmbedded.setter
    def useEmbedded(self, value: bool) -> None:
        if isinstance(value, bool):
            self.__useEmbedded = value

    def _parse(self):
        """
        _parse parse command line
        """

        strCommand = self.__bashCommand
        if self.useEmbedded:
            strCommand = self.__embeddedBashCommand

        self.__lstAnalysis = []

        rg = r"^(.*?)\s--.*?--output.(.*?)\s--.*?\s'\('\s(.*?)\s'\)'.*?--track-order\s(.*)"
        rgOneTrack = r"^(.*?)\s--.*?--output.(.*?)\s--.*?\s'\('\s(.*?)\s'\)'.*?"
        reCommandEx = re.compile(rg)
        reCommandOneTrackEx = re.compile(rgOneTrack)

        self.__errorFound = False

        # To be sound and look Ok
        # must match the 4 expected groups in the
        # command line
        # 1: mkvmerge name with fullpath
        # 2: output file
        # 3: at list one source
        # 4: track order for files with more than one track
        if (matchCommand := reCommandEx.match(strCommand)) and (
            len(matchCommand.groups()) == 4  # pylint: disable=used-before-assignment
        ):
            self.cliTracksOrder = matchCommand.group(4)
            self.__lstAnalysis.append("chk: Command seems ok.")
            try:
                d = ast.literal_eval("{" + self.cliTracksOrder + "}")
                trackTotal = numberOfTracksInCommand(strCommand)
                s = self.cliTracksOrder.split(",")
                if trackTotal == len(s):
                    for e in s:
                        if not e.find(":") > 0:
                            self.__errorFound = True
                else:
                    self.__errorFound = True
                if self.__errorFound:
                    self.__lstAnalysis.append(
                        "err: Number of tracks {} and track order of {} don't match.".format(
                            trackTotal, len(d)
                        )
                    )
            except SyntaxError:
                self.__lstAnalysis.append("err: Command track order bad format.")
                self.__errorFound = True
        elif (matchCommand := reCommandOneTrackEx.match(strCommand)) and (
            len(matchCommand.groups()) == 3  # pylint: disable=used-before-assignment
        ):
            self.cliTracksOrder = None
            self.__lstAnalysis.append("chk: Command seems ok.")
        else:
            self.__lstAnalysis.append("err: Command bad format.")
            self.__errorFound = True

        self.originalCommandTemplate, dMatch = generateCommandTemplate(
            strCommand, attachments=self.oAttachments, setTitle=self.__setTitles
        )

        # if matchUILanguage := reLanguageEx.search(strCommand):
        #    self.language = matchUILanguage.group(1)

        if dMatch[MKVParseKey.mkvmergeMatch]:
            f = stripEncaseQuotes(dMatch[MKVParseKey.mkvmergeMatch])
            p = Path(f)
            try:
                test = p.is_file()
            except OSError:
                self.__lstAnalysis.append(
                    "err: mkvmerge incorrect syntax - {}.".format(str(p))
                )
                self.__errorFound = True
            else:
                if test:
                    self.mkvmerge = p
                    self.mkvpropedit = str(p.parent) + "mkvpropedit"
                    self.__lstAnalysis.append("chk: mkvmerge ok - {}.".format(str(p)))
                else:
                    self.__lstAnalysis.append(
                        "err: mkvmerge not found - {}.".format(str(p))
                    )
                    self.__errorFound = True
        else:
            self.__lstAnalysis.append("err: mkvmerge not found in command.")
            self.__errorFound = True

        if dMatch[MKVParseKey.outputMatch]:
            self.cliOutputFile = None
            # self.cliOutputFileMatchString = None
            f = stripEncaseQuotes(dMatch[MKVParseKey.outputMatch])
            f = f.replace(r"'\''", "'")
            p = Path(f)
            try:
                test = Path(p.parent).is_dir()
            except OSError:
                self.__errorFound = True
                self.__lstAnalysis.append(
                    "err: Destination directory incorrect syntax - {}.".format(
                        str(p.parent)
                    )
                )
            else:
                if test:
                    self.cliOutputFile = p
                    # self.cliOutputFileMatchString = matchOutputFile.group(1)
                    self.__lstAnalysis.append(
                        "chk: Destination directory ok = {}.".format(str(p.parent))
                    )
                else:
                    self.__errorFound = True
                    self.__lstAnalysis.append(
                        "err: Destination directory not found - {}.".format(
                            str(p.parent)
                        )
                    )
        else:
            self.__errorFound = True
            self.__lstAnalysis.append("err: No output file found in command.")

        #
        # From here IO starts
        #
        if dMatch[MKVParseKey.baseFilesMatch]:
            for index, match in enumerate(dMatch[MKVParseKey.baseFilesMatch]):
                oFile = SourceFile(match, index)
                if oFile:
                    self.oSourceFiles.append(oFile)
                    if self.__totalSourceFiles is None:
                        self.__totalSourceFiles = len(oFile.filesInDir)
                        self.tracksOrder = [
                            self.cliTracksOrder
                        ] * self.__totalSourceFiles
                    self.__lstAnalysis.append(
                        "chk: Source directory ok - {}.".format(
                            str(oFile.fileName.parent)
                        )
                    )
                    if index == 0:
                        # Fill the output files list for files by key
                        # resolving any overwrite first source is the
                        # base for the output file names
                        self.filesInDirByKey[MKVParseKey.outputFile] = []
                        self.dirsByKey[MKVParseKey.outputFile] = ""
                        for f in oFile.filesInDir:
                            if self.dirsByKey[MKVParseKey.outputFile] == "":
                                self.dirsByKey[
                                    MKVParseKey.outputFile
                                ] = oFile.fileName.parent

                            of = self.cliOutputFile.parent.joinpath(
                                f.stem + self.outputFileExtension
                            )
                            of = resolveOverwrite(of)
                            self.filesInDirByKey[MKVParseKey.outputFile].append(of)
                    key = "<SOURCE{}>".format(str(index))
                    self.filesInDirByKey[key] = oFile.filesInDir
                    self.dirsByKey[key] = oFile.fileName.parent
                    if len(oFile.filesInDir) != self.__totalSourceFiles:
                        self.__errorFound = True
                        self.__lstAnalysis.append(
                            "err: Error source files TOTAL mismatched." + match
                        )
                else:
                    self.__errorFound = True
                    self.__lstAnalysis.append(
                        "err: Error reading source files." + match
                    )
        else:
            self.__errorFound = True
            self.__lstAnalysis.append("err: No source file found in command.")

        self.commandTemplate = str(self.originalCommandTemplate)

        # if self.preserveTrackNames:
        #    preserveNames(self)

        self.commandTemplates = [self.commandTemplate] * len(self)

        #
        # Optional
        #
        if dMatch[MKVParseKey.chaptersMatch]:
            self.cliChaptersFile = None
            f = unQuote(dMatch[MKVParseKey.chaptersMatch])
            p = Path(f)
            try:
                test = p.is_file()
            except OSError:
                self.__lstAnalysis.append(
                    "err: Chapters file incorrect syntax - {}.".format(str(p))
                )
                self.__errorFound = True
            else:
                if test:
                    self.cliChaptersFile = p
                    self.__lstAnalysis.append(
                        "chk: Chapters file ok - {}.".format(str(p.parent))
                    )
                else:
                    self.__lstAnalysis.append(
                        "chk: Chapters file not found - {}.".format(str(p.parent))
                    )
                    self.__errorFound = True

    def _readDirs(self):
        """
        _readDirs read files in directories
        """

        # Attachments can be in command for all files or one directory per file
        if self.oAttachments:
            if self.oAttachments.isAttachmentsDirByEpisode:
                for oDir in self.oAttachments.attachmentsDirs:
                    self.__lstAnalysis.append(
                        "chk: Attachments directory ok - {}.".format(str(oDir))
                    )
            else:
                for oDir in self.oAttachments.cmdLineAttachmentsDirs:
                    self.__lstAnalysis.append(
                        "chk: Attachments directory ok - {}.".format(str(oDir))
                    )

        # get title from first source file and use that if defined
        if self.__setTitles:
            # ADD to library
            for mediaInfo in self.oSourceFiles.sourceFiles[0].filesMediaInfo:
                if mediaInfo:
                    self.titles.append(mediaInfo.title)
                else:
                    self.titles.append("")

        if self.cliChaptersFile:
            d = self.cliChaptersFile.parent
            fid = [x for x in d.glob("*" + self.cliChaptersFile.suffix) if x.is_file()]
            fid = natsorted(fid, alg=ns.PATH)
            self.chaptersFiles.extend(fid)

        if self.log:
            for line in self.__lstAnalysis:
                if line.find("chk:") >= 0:
                    MODULELOG.debug("MCP0001: %s", line)
                elif line.find("err:") >= 0:
                    MODULELOG.error("MCP0002: %s", line)

    def _filesInDirByKey(self):

        if self.oAttachments.cmdLineAttachments:
            self.filesInDirByKey[
                MKVParseKey.attachmentFiles
            ] = self.oAttachments.attachmentsStr
        if self.__setTitles:
            self.filesInDirByKey[MKVParseKey.title] = self.titles
        if self.chaptersFiles:
            self.filesInDirByKey[MKVParseKey.chaptersFile] = self.chaptersFiles

    def createKeysDictionary(self, index, tracksOrder=None):
        """
        createKeysDictionary create a keys dictionary for template substitution

        Args:
            index (int): command index

        Returns:
            dict: dictionary of keys
        """

        keyDictionary = {}
        for key, sourceFile in self.filesInDirByKey.items():
            if key != MKVParseKey.attachmentFiles:
                keyDictionary[key] = shlex.quote(str(sourceFile[index]))
            else:
                keyDictionary[key] = sourceFile[index]
        if tracksOrder is not None:
            keyDictionary[MKVParseKey.trackOrder] = tracksOrder
        else:
            keyDictionary[MKVParseKey.trackOrder] = self.tracksOrder[index]

        return keyDictionary

    def generateCommands(self):
        """
        generateCommands genrate and store all command lines needed
        """

        if not self.__errorFound:
            totalCommands = len(self.filesInDirByKey[MKVParseKey.outputFile])
            self.__strCommands = []
            self.__shellCommands = []

            for i in range(totalCommands):

                self.__strCommands.append(None)
                self.__shellCommands.append(None)

                _, _ = self.generateCommandByIndex(i, update=True)

    def generateCommandByIndex(
        self, index, update=False, template=None, tracksOrder=None
    ):
        """
        generateCommandByIndex generate a command for a determined index

        Args:
            index (int): index of command been worked on
            shell (bool, optional): If True return a shell command for subprocess
                otherwise return cli command. Defaults to False.

        Returns:
            str: final command
        """

        if template is not None:
            cmdTemplate = template
        else:
            cmdTemplate = self.commandTemplates[index]
        keyDictionary = self.createKeysDictionary(index, tracksOrder=tracksOrder)
        strCommand = generateCommand(cmdTemplate, keyDictionary)
        shellCommand = shlex.split(
            strCommand
        )  # save command as shlex.split to submit to Pipe

        if update:
            self.__strCommands[index] = strCommand
            self.__shellCommands[index] = shellCommand

        return strCommand, shellCommand

    def readFiles(self):
        if not self.__errorFound:
            self._readDirs()
            self._filesInDirByKey()

    def renameOutputFiles(self, newNames):

        if len(newNames) == self.__totalSourceFiles:
            self.newNames = list(newNames)
            self.filesInDirByKey[MKVParseKey.outputFile] = self.newNames
            self.generateCommands()

def embeddedBashCommand(strCommand: str, mkvmergeEmbedded) -> str:

    strEmbeddedCommand = None
    if (mkvmergeMatch:= MKVCommandParser.reMkvMergeEx.match(strCommand)):
        # configure embedded variables
        strEmbedded = setEncaseQuotes(mkvmergeEmbedded.as_posix())
        strEmbeddedCommand = re.sub(
            mkvmergeMatch[1],
            strEmbedded,
            strCommand
        )

    return strEmbeddedCommand


def preserveNames(self):
    """
    preserveNames alter template if track names have to be preserved
    """

    cmdTemplate = self.originalCommandTemplate
    correctionDone = False

    for oBaseFile in self.oSourceFiles.oBaseFiles:

        if oBaseFile.trackOptions.hasNamesToPreserve:
            matchString = oBaseFile.fullMatchStringWithKey()
            templateCorrection = oBaseFile.fullMatchStringCorrected(withKey=True)
            cmdTemplate = cmdTemplate.replace(matchString, templateCorrection, 1)
            if not correctionDone:
                correctionDone = True

    if correctionDone:
        self.commandTemplate = cmdTemplate
