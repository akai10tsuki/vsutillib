"""
 Parse mkvmerge into a class

Track options assumed appear after --language

r"|--sync "
r"|--cues "
r"|--default-track "
r"|--forced-track "
r"|--blockadd "
r"|--track-name "
r"|--tags "
r"|--aac-is-sbr "
r"|--reduce-to-core "
r"|--remove-dialog-normalization-gain  "
r"|--timestamps "
r"|--default-duration "
r"|--fix-bitstream-timing-information "
r"|--nalu-size-length "
r"|--compression "

"""

import ast
import logging
import re
import shlex

from pathlib import Path

from vsutillib.media import MediaFileInfo

from ..mkvutils import (
    convertToBashStyle,
    numberOfTracksInCommand,
    resolveOverwrite,
    stripEncaseQuotes,
    unQuote,
)
from .mkvclassutil import Attachment, SourceFile
from .mkvgetattachments import MKVGetAttachments

MODULELOG = logging.getLogger(__name__)
MODULELOG.addHandler(logging.NullHandler())


class MKVCommandParser:
    """
    Class for parsing CLI **mkvmerge** command part of MKVToolnix_

    Args:
        strCommand (`str`, optional): command line as generated by mkvtoolnix-gui
    """

    __log = False

    @classmethod
    def classLog(cls, setLogging=None):
        """
        get/set logging at class level
        every class instance will log
        unless overwritten

        Args:
            setLogging (bool):
                - True class will log
                - False turn off logging
                - None returns current Value

        Returns:
            bool:

            returns the current value set
        """

        if setLogging is not None:
            if isinstance(setLogging, bool):
                cls.__log = setLogging

        return cls.__log

    def __init__(self, strCommand=None, log=None):

        self.__bashCommand = None
        self.__errorFound = False
        self.__lstAnalysis = None
        self.__log = None
        self.__totalSourceFiles = None
        self.__strCommand = None

        self.chaptersFile = None
        self.chaptersLanguage = None
        self.commandTemplate = None
        self.language = None
        self.mkvmerge = None
        self.outputFile = None
        self.title = None
        self.titleMatchString = None
        self.trackOrder = None

        self.attachments = []
        self.attachmentFiles = []
        self.chaptersFiles = []
        self.filesInDirByKey = {}
        self.outputFiles = []
        self.sourceFiles = []
        self.titles = []

        self.log = log
        self.command = strCommand

    def __reset(self):

        self.__errorFound = False
        self.__lstAnalysis = None
        self.__totalSourceFiles = None

        # self.chaptersFile = None
        # self.chaptersLanguage = None
        # self.commandTemplate = None
        # self.language = None
        # self.mkvmerge = None
        # self.outputFile = None
        # self.title = None
        # self.titleMatchString = None
        self.trackOrder = None

        self.attachments = []
        self.attachmentFiles = []
        self.chaptersFiles = []
        self.filesInDirByKey = {}
        self.outputFiles = []
        self.sourceFiles = []
        self.titles = []

    def __bool__(self):
        return not self.__errorFound

    def __len__(self):
        return self.__totalSourceFiles

    def __str__(self):

        strCommand = shlex.quote(str(self.mkvmerge))
        strCommand += " --ui-language " + self.language
        strCommand += " --output " + shlex.quote(str(self.outputFile))
        for oFile in self.sourceFiles:
            # for track in oFile.tracks:
            #    strCommand += " " + track
            strCommand += " " + oFile.options
            strCommand += " '(' " + shlex.quote(str(oFile.fileName)) + " ')'"
        for oAttach in self.attachments:
            strCommand += " " + str(oAttach)
        if self.title:
            strCommand += " --title " + self.title
        if self.chaptersFile:
            strCommand += " --chapter-language " + self.chaptersLanguage
            strCommand += " --chapters " + shlex.quote(str(self.chaptersFile))
        strCommand += " --track-order " + self.trackOrder

        return strCommand

    @property
    def log(self):
        """
        class property can be used to override the class global
        logging setting

            bool:

            True if logging is enable False otherwise
        """
        if self.__log is not None:
            return self.__log

        return MKVCommandParser.classLog()

    @log.setter
    def log(self, value):
        """set instance log variable"""
        if isinstance(value, bool) or value is None:
            self.__log = value

    @property
    def attachmentsDirs(self):
        """
        attachmentsDirs get attachments directories

        Returns:
            list: list with unique directories found
        """

        dirs = set()

        if self.attachments:
            for a in self.attachments:
                dirs.add(a.fileName.parent)

        return list(dirs)

    @property
    def attachmentsSpan(self):
        span = ()
        if self.attachments:
            span = (self.attachments[0].span[0], self.attachments[-1].span[1])

        return span

    @property
    def attachmentsMatchString(self):
        strTmp = None
        if self.attachments:
            span = self.attachmentsSpan
            strTmp = self.bashCommand[span[0] : span[1]]
        return strTmp

    @property
    def bashCommand(self):
        return self.__bashCommand

    @property
    def command(self):
        return self.__strCommand

    @command.setter
    def command(self, value):
        if isinstance(value, str):
            self.__reset()
            self.__strCommand = value
            strCommand = convertToBashStyle(
                self.__strCommand
            )  # Comvert command line to bash style
            self.__bashCommand = strCommand
            self._parse()
            if not self.__errorFound:
                self._template()
                self._attachments()
                self._readDirs()
                self._filesInDirByKey()

    def _parse(self):

        strCommand = self.__bashCommand

        self.__lstAnalysis = []

        rg = r"^(.*?)\s--.*?--output.(.*?)\s--.*?\s'\('\s(.*?)\s'\)'.*?--track-order\s(.*)"

        reCommandEx = re.compile(rg)
        matchCommand = reCommandEx.match(strCommand)

        reExecutableEx = re.compile(r"^(.*?)\s--")
        matchExecutable = reExecutableEx.match(strCommand)

        reLanguageEx = re.compile(r"--ui-language (.*?) --")
        matchUILanguage = reLanguageEx.search(strCommand)

        reOutputFileEx = re.compile(r".*?--output\s(.*?)\s--")
        matchOutputFile = reOutputFileEx.match(strCommand)

        reFilesEx = re.compile(
            (
                r"(?=--audio-tracks "
                r"|--video-tracks "
                r"|--subtitle-tracks "
                r"|--button-tracks "
                r"|--track-tags  "
                r"|--attachments "
                r"|--no-audio "
                r"|--no-video "
                r"|--no-subtitles "
                r"|--no-buttons "
                r"|--no-track-tags "
                r"|--no-chapters "
                r"|--no-global-tags "
                r"|--chapter-charset "
                r"|--chapter-language "
                r"|--language "
                r")"
                r"(.*?) '\(' (.*?) '\)'"
            )
        )
        matchFiles = reFilesEx.finditer(strCommand)

        reAttachmentsEx = re.compile(
            (
                r"--attachment-name (.*?) --attachment-mime-type "
                r"(.*?) --attach-file (.*?)(?= --)"
            )
        )
        matchAttachments = reAttachmentsEx.finditer(strCommand)

        reTitleEx = re.compile(r"--title (.*?)(?= --)")
        matchTitle = reTitleEx.search(strCommand)

        reChaptersFileEx = re.compile(
            r"--chapter-language (.*?) --chapters (.*?) (?=--)"
        )
        matchChaptersFile = reChaptersFileEx.search(strCommand)

        self.__errorFound = False
        # self.trackOrder = None

        # To look Ok must match the 4 expected groups in the
        # command line
        # 1: mkvmerge name with fullpath
        # 2: output file
        # 3: at list one source
        # 4: track order
        if matchCommand and (len(matchCommand.groups()) == 4):
            self.trackOrder = matchCommand.group(4)
            self.__lstAnalysis.append("chk: Command seems ok.")
            try:
                d = ast.literal_eval("{" + self.trackOrder + "}")
                trackTotal = numberOfTracksInCommand(strCommand)
                s = self.trackOrder.split(",")
                if trackTotal == len(s):
                    for e in s:
                        if not e.find(":") > 0:
                            self.__errorFound = True
                else:
                    self.__errorFound = True
                if self.__errorFound:
                    self.__lstAnalysis.append(
                        "err: Number of tracks {} and track order of {} don't match.".format(
                            trackTotal, len(d)
                        )
                    )
            except SyntaxError:
                self.__lstAnalysis.append("err: Command track order bad format.")
                self.__errorFound = True
        else:
            self.__lstAnalysis.append("err: Command bad format.")
            self.__errorFound = True

        if matchUILanguage:
            self.language = matchUILanguage.group(1)

        if matchExecutable:
            f = stripEncaseQuotes(matchExecutable.group(1))
            p = Path(f)
            if p.is_file():
                self.mkvmerge = p
                self.__lstAnalysis.append("chk: mkvmerge ok - {}".format(str(p)))
            else:
                self.__lstAnalysis.append(
                    "err: mkvmerge not found - {}.".format(str(p))
                )
                self.__errorFound = True
        else:
            self.__lstAnalysis.append("err: mkvmerge not found.")
            self.__errorFound = True

        if matchOutputFile:
            f = stripEncaseQuotes(matchOutputFile.group(1))
            f = f.replace(r"'\''", "'")
            p = Path(f)

            if Path(p.parent).is_dir():
                self.outputFile = p
                self.__lstAnalysis.append(
                    "chk: Destination directory ok = {}".format(str(p.parent))
                )
            else:
                self.outputFile = None
                self.__errorFound = True
                self.__lstAnalysis.append(
                    "err: Destination directory not found - {}.".format(str(p.parent))
                )
        else:
            self.__errorFound = True
            self.__lstAnalysis.append("err: No output file found in command.")

        if matchFiles:
            for match in matchFiles:
                oFile = SourceFile(match.group(0))
                if oFile:
                    self.sourceFiles.append(oFile)
                    if self.__totalSourceFiles is None:
                        self.__totalSourceFiles = len(oFile.filesInDir)
                else:
                    self.__errorFound = True
                    self.__lstAnalysis.append(
                        "err: Error reading source files " + match.group(2)
                    )

        else:
            self.__errorFound = True
            self.__lstAnalysis.append("err: No source file found in command.")

        #
        # Optional
        #
        if matchAttachments:
            for match in matchAttachments:
                attachment = Attachment(match.groups(), match.span(), match.group())
                self.attachments.append(attachment)

        if matchTitle:
            self.titleMatchString = matchTitle.group(0)
            self.title = matchTitle.group(1)

        if matchChaptersFile:
            self.chaptersLanguage = matchChaptersFile.group(1)
            f = unQuote(matchChaptersFile.group(2))
            p = Path(f)

            if p.is_file():
                self.chaptersFile = p

    def _attachments(self):
        # Attachments
        if self.attachments:
            attachFiles = MKVGetAttachments(self)
            self.attachmentFiles.extend(attachFiles.attachments)

    def _readDirs(self):

        for f in self.sourceFiles[0].filesInDir:
            mediaInfo = MediaFileInfo(str(f))
            if mediaInfo:
                self.titles.append(mediaInfo.title)
            else:
                self.titles.append("")

            of = self.outputFile.parent.joinpath(f.stem + ".mkv")
            of = resolveOverwrite(of)
            self.outputFiles.append(of)

        if self.chaptersFile:
            d = self.chaptersFile.parent
            fid = [x for x in d.glob("*" + self.chaptersFile.suffix) if x.is_file()]
            self.chaptersFiles.extend(fid)

    def _filesInDirByKey(self):

        if self.attachments:
            self.filesInDirByKey[_Key.attachmentFiles] = self.attachmentFiles

        self.filesInDirByKey[_Key.chaptersFile] = self.chaptersFiles
        self.filesInDirByKey[_Key.outputFile] = self.outputFiles
        self.filesInDirByKey[_Key.title] = self.titles

        for index, source in enumerate(self.sourceFiles):
            key = "<SOURCE{}>".format(str(index))
            self.filesInDirByKey[key] = source.filesInDir

    def _template(self):

        cmdTemplate = self.__bashCommand

        cmdTemplate = cmdTemplate.replace(
            shlex.quote(str(self.outputFile)), _Key.outputFile, 1
        )

        for index, sf in enumerate(self.sourceFiles):
            key = "<SOURCE{}>".format(str(index))
            cmdTemplate = cmdTemplate.replace(sf.matchString, key, 1)

        if self.attachments:
            cmdTemplate = cmdTemplate.replace(
                self.attachmentsMatchString, _Key.attachmentFiles, 1
            )

        if self.title:
            cmdTemplate = cmdTemplate.replace(
                self.titleMatchString, "--title " + _Key.title, 1
            )

        if self.chaptersFile:
            cmdTemplate = cmdTemplate.replace(
                shlex.quote(str(self.chaptersFile)), _Key.chaptersFile, 1
            )

        self.commandTemplate = cmdTemplate


class _Key:

    attachmentFiles = "<ATTACHMENTS>"
    chaptersFile = "<CHAPTERS>"
    outputFile = "<OUTPUTFILE>"
    title = "<TITLE>"
