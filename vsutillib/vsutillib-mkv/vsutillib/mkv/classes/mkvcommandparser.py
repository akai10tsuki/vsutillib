"""
 Parse mkvmerge into a class

Track options assumed appear after --language

r"|--sync "
r"|--cues "
r"|--default-track "
r"|--forced-track "
r"|--blockadd "
r"|--track-name "
r"|--tags "
r"|--aac-is-sbr "
r"|--reduce-to-core "
r"|--remove-dialog-normalization-gain  "
r"|--timestamps "
r"|--default-duration "
r"|--fix-bitstream-timing-information "
r"|--nalu-size-length "
r"|--compression "

"""

import logging
import re
import shlex

from pathlib import Path

from vsutillib.media import MediaFileInfo
from vsutillib.files import stripEncaseQuotes

from .mkvgetattachments import MKVGetAttachments

MODULELOG = logging.getLogger(__name__)
MODULELOG.addHandler(logging.NullHandler())


class MKVCommandParser:
    """
    Class for parsing CLI **mkvmerge** command part of MKVToolnix_

    Args:
        strCommand (`str`, optional): command line as generated by mkvtoolnix-gui
    """

    __log = False

    @classmethod
    def classLog(cls, setLogging=None):
        """
        get/set logging at class level
        every class instance will log
        unless overwritten

        Args:
            setLogging (bool):
                - True class will log
                - False turn off logging
                - None returns current Value

        Returns:
            bool:

            returns the current value set
        """

        if setLogging is not None:
            if isinstance(setLogging, bool):
                cls.__log = setLogging

        return cls.__log

    def __init__(self, strCommand=None, log=None):

        self.__bashCommand = None
        self.__lstAnalysis = None
        self.__totalSourceFiles = None
        self.__strCommand = None

        self.chaptersFile = None
        self.chaptersLanguage = None
        self.commandTemplate = None
        self.language = None
        self.mkvmerge = None
        self.outputFile = None
        self.title = None
        self.titleMatchString = None
        self.trackOrder = None

        self.attachments = []
        self.attachmentFiles = []
        self.chaptersFiles = []
        self.filesInDirByKey = {}
        self.outputFiles = []
        self.sourceFiles = []
        self.titles = []

        self.command = strCommand
        self.log = log

    def __str__(self):

        strCommand = shlex.quote(str(self.mkvmerge))
        strCommand += " --ui-language " + self.language
        strCommand += " --output " + shlex.quote(str(self.outputFile))
        for oFile in self.sourceFiles:
            # for track in oFile.tracks:
            #    strCommand += " " + track
            strCommand += " " + oFile.options
            strCommand += " '(' " + shlex.quote(str(oFile.fileName)) + " ')'"
        for oAttach in self.attachments:
            strCommand += " " + str(oAttach)
        if self.title:
            strCommand += " --title " + self.title
        if self.chaptersFile:
            strCommand += " --chapter-language " + self.chaptersLanguage
            strCommand += " --chapters " + shlex.quote(str(self.chaptersFile))
        strCommand += " --track-order " + self.trackOrder

        return strCommand

    def __len__(self):
        return self.__totalSourceFiles

    @property
    def log(self):
        """
        class property can be used to override the class global
        logging setting

            bool:

            True if logging is enable False otherwise
        """
        if self.__log is not None:
            return self.__log

        return MKVCommandParser.classLog()

    @log.setter
    def log(self, value):
        """set instance log variable"""
        if isinstance(value, bool) or value is None:
            self.__log = value

    @property
    def attachmentsDirs(self):
        """
        attachmentsDirs get attachments directories

        Returns:
            list: list with unique directories found
        """

        dirs = set()

        if self.attachments:
            for a in self.attachments:
                dirs.add(a.fileName.parent)

        return list(dirs)

    @property
    def attachmentsSpan(self):
        span = ()
        if self.attachments:
            span = (self.attachments[0].span[0], self.attachments[-1].span[1])

        return span

    @property
    def attachmentsMatchString(self):
        strTmp = None
        if self.attachments:
            span = self.attachmentsSpan
            strTmp = self.bashCommand[span[0] : span[1]]
        return strTmp

    @property
    def bashCommand(self):
        return self.__bashCommand

    @property
    def command(self):
        return self.__strCommand

    @command.setter
    def command(self, value):
        if isinstance(value, str):
            self._reset()
            self.__strCommand = value
            strCommand = _convertToBashStyle(
                self.__strCommand
            )  # Comvert command line to bash style
            self.__bashCommand = strCommand
            self._parse()
            self._template()
            self._attachments()
            self._readDirs()
            self._filesInDirByKey()

    def _reset(self):

        self.__lstAnalysis = None
        self.__totalSourceFiles = None

        self.chaptersFile = None
        self.chaptersLanguage = None
        self.commandTemplate = None
        self.language = None
        self.mkvmerge = None
        self.outputFile = None
        self.title = None
        self.titleMatchString = None
        self.trackOrder = None

        self.attachments = []
        self.attachmentFiles = []
        self.chaptersFiles = []
        self.filesInDirByKey = {}
        self.outputFiles = []
        self.sourceFiles = []
        self.titles = []

    def _parse(self):

        strCommand = self.__bashCommand

        self.__lstAnalysis = []

        rg = r"^(.*?)\s--.*?--output.(.*?)\s--.*?\s'\('\s(.*?)\s'\)'.*?--track-order\s(.*)"

        reCommandEx = re.compile(rg)
        matchCommand = reCommandEx.match(strCommand)

        reExecutableEx = re.compile(r"^(.*?)\s--")
        matchExecutable = reExecutableEx.match(strCommand)

        reLanguageEx = re.compile(r"--ui-language (.*?) --")
        matchUILanguage = reLanguageEx.search(strCommand)

        reOutputFileEx = re.compile(r".*?--output\s(.*?)\s--")
        matchOutputFile = reOutputFileEx.match(strCommand)

        reFilesEx = re.compile(
            (
                r"(?=--audio-tracks "
                r"|--video-tracks "
                r"|--subtitle-tracks "
                r"|--button-tracks "
                r"|--track-tags  "
                r"|--attachments "
                r"|--no-audio "
                r"|--no-video "
                r"|--no-subtitles "
                r"|--no-buttons "
                r"|--no-track-tags "
                r"|--no-chapters "
                r"|--no-global-tags "
                r"|--chapter-charset "
                r"|--chapter-language "
                r"|--language "
                r")"
                r"(.*?) (?='\)')"
            )
        )
        matchFiles = reFilesEx.findall(strCommand)

        reAttachmentsEx = re.compile(
            (
                r"--attachment-name (.*?) --attachment-mime-type "
                r"(.*?) --attach-file (.*?)(?= --)"
            )
        )
        matchAttachments = reAttachmentsEx.finditer(strCommand)

        reTitleEx = re.compile(r"--title (.*?)(?= --)")
        matchTitle = reTitleEx.search(strCommand)

        reChaptersFileEx = re.compile(
            r"--chapter-language (.*?) --chapters (.*?) (?=--)"
        )
        matchChaptersFile = reChaptersFileEx.search(strCommand)

        # To look Ok must match the 4 expected groups in the
        # command line
        # 1: mkvmerge name with fullpath
        # 2: output file
        # 3: at list one source
        # 4: track order
        if matchCommand and (len(matchCommand.groups()) == 4):
            self.trackOrder = matchCommand.group(4)

        if matchUILanguage:
            self.language = matchUILanguage.group(1)

        if matchExecutable:
            f = stripEncaseQuotes(matchExecutable.group(1))
            p = Path(f)
            if p.is_file():
                self.mkvmerge = p

        if matchOutputFile:
            f = stripEncaseQuotes(matchOutputFile.group(1))
            f = f.replace(r"'\''", "'")
            p = Path(f)

            if Path(p.parent).is_dir():
                self.outputFile = p

        if matchFiles:
            for match in matchFiles:
                m = match + " ')'"
                oFile = SourceFile(m)
                self.sourceFiles.append(oFile)
                if self.__totalSourceFiles is None:
                    self.__totalSourceFiles = len(oFile.filesInDir)

        if matchAttachments:
            for match in matchAttachments:
                attachment = Attachment(match.groups(), match.span(), match.group())
                self.attachments.append(attachment)

        if matchTitle:
            self.titleMatchString = matchTitle.group(0)
            self.title = matchTitle.group(1)

        if matchChaptersFile:
            self.chaptersLanguage = matchChaptersFile.group(1)
            f = _unQuote(matchChaptersFile.group(2))
            p = Path(f)

            if p.is_file():
                self.chaptersFile = p

    def _attachments(self):
        # Attachments
        if self.attachments:
            attachFiles = MKVGetAttachments(self)
            self.attachmentFiles.extend(attachFiles.attachments)

    def _readDirs(self):

        for f in self.sourceFiles[0].filesInDir:
            mediaInfo = MediaFileInfo(str(f))
            if mediaInfo:
                self.titles.append(mediaInfo.title)
            else:
                self.titles.append("")

            of = self.outputFile.parent.joinpath(f.stem + ".mkv")
            of = _resolveOverwrite(of)
            self.outputFiles.append(of)

        if self.chaptersFile:
            d = self.chaptersFile.parent
            fid = [x for x in d.glob("*" + self.chaptersFile.suffix) if x.is_file()]
            self.chaptersFiles.extend(fid)


    def _filesInDirByKey(self):

        if self.attachments:
            self.filesInDirByKey[_Key.attachmentFiles] = self.attachmentFiles

        self.filesInDirByKey[_Key.chaptersFile] = self.chaptersFiles
        self.filesInDirByKey[_Key.outputFile] = self.outputFiles
        self.filesInDirByKey[_Key.title] = self.titles

        for index, source in self.sourceFiles:
            key = "<SOURCE{}>".format(str(index))
            self.filesInDirByKey[key] = source.filesInDir


    def _template(self):

        cmdTemplate = self.__bashCommand

        cmdTemplate = cmdTemplate.replace(
            shlex.quote(str(self.outputFile)), _Key.outputFile, 1
        )

        for index, sf in enumerate(self.sourceFiles):
            key = "<SOURCE{}>".format(str(index))
            cmdTemplate = cmdTemplate.replace(sf.matchString, key, 1)

        if self.attachments:
            cmdTemplate = cmdTemplate.replace(
                self.attachmentsMatchString, _Key.attachmentFiles, 1
            )

        if self.title:
            cmdTemplate = cmdTemplate.replace(
                self.titleMatchString, "--title " + _Key.title, 1
            )

        if self.chaptersFile:
            cmdTemplate = cmdTemplate.replace(
                shlex.quote(str(self.chaptersFile)), _Key.chaptersFile, 1
            )

        self.commandTemplate = cmdTemplate


class Attachment:  # pylint: disable=too-few-public-methods
    """
    Class to save attachment information

    """

    def __init__(self, attachment, span=None, matchString=None):

        self.name = None
        self.mimeType = None
        self.fileName = None

        if isinstance(attachment, tuple):
            self.name = attachment[0]
            self.mimeType = attachment[1]

            f = _unQuote(attachment[2])
            p = Path(f)

            if p.is_file():
                self.fileName = p

        self.span = span
        self.matchString = matchString

    def __str__(self):

        return self.matchString


class SourceFile:
    """
     Tracks and file names
    """

    def __init__(self, strParseFile=None):

        self.__ParseFile = strParseFile
        self.options = None
        self.tracks = []
        self.filesInDir = []
        self.fileName = None
        self.matchString = None
        if self.__ParseFile:
            self._parse()

    def _parse(self):

        reTrackEx = re.compile(r"(?=--language )(.*?) (?=--language|'\(')")
        reOptionsEx = re.compile(
            (
                r"(?=--audio-tracks "
                r"|--video-tracks "
                r"|--subtitle-tracks "
                r"|--button-tracks "
                r"|--track-tags  "
                r"|--attachments "
                r"|--no-audio "
                r"|--no-video "
                r"|--no-subtitles "
                r"|--no-buttons "
                r"|--no-track-tags "
                r"|--no-chapters "
                r"|--no-global-tags "
                r"|--chapter-charset "
                r"|--chapter-language "
                r"|--language "
                r")(.*?) (?='\(')"
            )
        )
        reSourcesEx = re.compile(r"'\('\s(.*?)\s'\)'")
        self.tracks = []
        self.fileName = []

        if self.__ParseFile:
            if match := reTrackEx.finditer(self.__ParseFile):
                for m in match:
                    self.tracks.append(m.group(1))
            if match := reOptionsEx.search(self.__ParseFile):
                self.options = match.group(1)
            if match := reSourcesEx.search(self.__ParseFile):
                f = _unQuote(match.group(1))
                p = Path(f)

                if p.is_file():
                    self.fileName = p
                    self.matchString = match.group(0)
                    d = p.parent
                    fid = [x for x in d.glob("*" + p.suffix) if x.is_file()]
                    self.filesInDir.extend(fid)

    @property
    def directory(self):
        return self.fileName.parent

    @property
    def strFile(self):
        return self.__ParseFile

    @strFile.setter
    def strFile(self, value):
        if isinstance(value, str):
            self.__ParseFile = value
            self._parse()


class _Key:

    attachmentFiles = "<ATTACHMENTS>"
    chaptersFile = "<CHAPTERS>"
    outputFile = "<OUTPUTFILE>"
    title = "<TITLE>"


def _convertToBashStyle(strCommand):
    """
    Strip escape windows chars for the command line
    in the end they won't be used in a shell
    the resulting command is bash/zh like

    Args:
        strCommand (str): command generated by mkvtoolnix-gui

    Returns:
        str:

        cli command converted to bash style
    """

    strTmp = strCommand

    if strTmp.find(r'^"^(^"') >= 0:
        # This is for cmd in Windows
        strTmp = (
            strTmp.replace("'", r"'\''")
            .replace("^", "")
            .replace("/", "\\")
            .replace('"', "'")
        )

    return strTmp


def _numberOfTracksInCommand(strCmd):
    """
    Every track have a --language option count
    them to know the number of tracks

    Args:
        strCmd(str): command line

    Returns:
        int:

        total number of tracks
    """

    reLanguageEx = re.compile(r"\-\-language (.*?)\s")
    matchLanguage = reLanguageEx.findall(strCmd)

    return len(matchLanguage)


def _resolveOverwrite(fileName, strPrefix="new-"):

    fileNameTmp = fileName

    # Check if destination file exist and add prefix if it does
    if fileNameTmp.is_file():

        strSuffix = ""
        n = 1

        while True:
            fileNameTmp = fileNameTmp.parent.joinpath(
                strPrefix + fileName.stem + strSuffix + fileName.suffix
            )

            if fileNameTmp.is_file():
                strSuffix = " ({})".format(n)
                n += 1
            else:
                break

    return fileNameTmp


def _unQuote(fileName):
    """
    Remove start end quotes and escape ones
    Args:
        fileName (str): file name

    Returns:
        str:

        file name without quotes if found
    """

    f = stripEncaseQuotes(fileName)
    f = f.replace(r"'\''", "'")

    return f
