"""
This class is used to construct the list used to execute the MKVMerge
command line

strCommand = Command obtained from mkvtoolnix-gui with the modifications
    needed for Multiplexing a series in a directory

path for executable and target options are parsed from the command line

"""


import re
import shlex
import logging


from pathlib import Path

from ..mkvutils import commandLooksOk, stripEncaseQuotes


MODULELOG = logging.getLogger(__name__)
MODULELOG.addHandler(logging.NullHandler())


class MKVCommand():
    """
    Class to work with mkvmerge command

    :param strCommand: command line as generated by mkvtoolnix-gui
    :type strCommand: str
    :param bRemoveTitle: remove title from command
    :type bRemoveTitle: bool
    """

    __log = False

    @classmethod
    def classLog(cls, setLogging=None):
        """
        get/set logging at class level
        every class instance will log
        unless overwritten
        """

        if setLogging is None:
            return cls.__log
        elif isinstance(setLogging, bool):
            cls.__log = setLogging

    def __init__(self, strCommand=None, bRemoveTitle=True):

        self.__destinationDirectory = None
        self.__lstCommands = []
        self.__strShellcommand = None
        self.__strError = ""
        self.__bErrorFound = False
        self.__workFiles = _WorkFiles()
        self.__commandTemplate = None

        self.__log = None

        print("Log = {}".format(self.log))

        # for iterator
        self.__index = 0

        if strCommand is not None:
            self._initHelper(strCommand, bRemoveTitle)

    def _initHelper(self, strCommand, bRemoveTitle=True):

        if strCommand is None:

            self.__reset()

        elif commandLooksOk(strCommand):

            self.__strShellCommand = strCommand
            lstSources = []

            reOutputFile = r"\-\-output\s(.*?)\s\-\-"
            reSourceFile = r"('\('\s(.*?)\s'\)')"

            reOutputFileEx = re.compile(reOutputFile)
            reSourcesEx = re.compile(reSourceFile)

            # search for the output file
            match = reOutputFileEx.search(strCommand)

            if match:
                strOutputFile = match.group(1)

            outputFile = Path(stripEncaseQuotes(strOutputFile))

            if outputFile.parent.is_dir():
                self.__destinationDirectory = outputFile.parent

            #
            # search for the source files
            # this have to exists in the
            # file system
            #
            match = reSourcesEx.findall((strCommand))

            if match:
                for m in match:
                    lstSources.append(m)

            newCommandTemplate = strCommand

            filesInDirsByKey = {}
            lstBaseFiles = []

            lenOfListOfFiles = 0

            for index, source in enumerate(lstSources):

                sub, fileName = source
                key = '<SOURCE{}>'.format(str(index))
                f = Path(stripEncaseQuotes(fileName))
                d = f.parent
                fd = [x for x in d.glob('*' + f.suffix) if x.is_file()]
                fd.sort(key=_strPath)

                if lenOfListOfFiles == 0:
                    lenOfListOfFiles = len(fd)
                elif lenOfListOfFiles != len(fd):
                    self.__reset()
                    self.__bErrorFound = True
                    self.__strError = "List of files are not equal."

                lstBaseFiles.append(f) # backwards compatible
                filesInDirsByKey[key] = fd
                newCommandTemplate = newCommandTemplate.replace(sub, key, 1)

                if index == 0:
                    od = []
                    for o in fd:
                        of = outputFile.parent.joinpath(o.stem + '.mkv')
                        of = _resolveOverwrite(of)
                        od.append(of)
                    filesInDirsByKey['<OUTPUTFILE>'] = od


            newCommandTemplate = newCommandTemplate.replace(strOutputFile, '<OUTPUTFILE>', 1)

            self.__commandTemplate = newCommandTemplate

            lstTmp = []
            lstTmp1 = []

            #
            # lstTmp list of the form:
            # [[('<SOURCE0>', file1), ('<SOURCE0>', file2), ...],
            #  [('<OUTFILE>', file1), ('<OUTFILE>', file2), ...],
            #  [('<SOURCE1>', file1), ('<SOURCE1>', file2), ...],
            #  ...]
            # theese are the individual list by key
            #
            for key in filesInDirsByKey:
                filesInDir = filesInDirsByKey[key]
                z = zip([key] * len(filesInDir), filesInDir)
                if key != '<OUTPUTFILE>':
                    lstTmp1.append(filesInDir)
                lstTmp.append(list(z))

            if self.log:
                MODULELOG.debug("MKV0006: Files by Key %s", str(lstTmp))
            #
            # list of the form:
            # [(('<SOURCE0>', file1), ('<OUTFILE>', file1), ('<SOURCE1>', file1), ...),
            #  (('<SOURCE0>', file2), ('<OUTFILE>', file2), ('<SOURCE1>', file2), ...),
            #  ...]
            # theese are the combined list of lstTmp unpacked and zip is applied
            # to have all the keys for substitution at the same point
            #
            lstSourceFilesWithKey = list(zip(*lstTmp))
            lstSourceFiles = list(zip(*lstTmp1)) # backwards compatible

            #
            # generate all the commands and store them in shlex form
            #
            for s in lstSourceFilesWithKey:

                newCommand = newCommandTemplate

                for e in s:
                    key, fileName = e
                    qf = shlex.quote(str(fileName))
                    newCommand = newCommand.replace(key, qf, 1)

                shellCommand = shlex.split(newCommand)

                if bRemoveTitle and shellCommand:
                    # Remove title if found since this is for batch processing
                    # the title will propagate to all the files maybe erroneously.
                    # This parameters are preserved from the source files.

                    while "--title" in shellCommand:

                        i = shellCommand.index("--title")
                        del shellCommand[i:i+2]

                self.__lstCommands.append(shellCommand)

            self.__workFiles.baseFiles = lstBaseFiles
            self.__workFiles.sourceFiles = lstSourceFiles
            self.__workFiles.destinationFiles = filesInDirsByKey['<OUTPUTFILE>']

            if self.log:
                MODULELOG.debug("MKV0001: Command template %s", str(self.__commandTemplate))
                MODULELOG.debug("MKV0002: Base files %s", str(self.__workFiles.baseFiles))
                MODULELOG.debug("MKV0003: Source files %s", str(self.__workFiles.sourceFiles))
                MODULELOG.debug(
                    "MKV0004: Destination files %s",
                    str(self.__workFiles.destinationFiles)
                )

        else:
            # error cannot process command
            self.__reset()
            self.__strError = "Error parsing command line."
            self.__bErrorFound = True

            if self.log:
                MODULELOG.error("MKV0005: %s", self.__strError)

    def __reset(self):
        """Reset variable properties"""

        self.__destinationDirectory = None
        self.__lstCommands = []
        self.__strShellcommand = None
        self.__strError = ""
        self.__index = 0
        self.__workFiles.clear()
        self.__commandTemplate = None

    def __bool__(self):
        return not self.__bErrorFound

    def __contains__(self, item):
        return item in self.__lstCommands

    def __getitem__(self, index):
        return [self.__lstCommands[index],
                self.__workFiles.baseFiles,
                self.__workFiles.sourceFiles[index],
                self.__workFiles.destinationFiles[index]]

    def __iter__(self):
        return self

    def __len__(self):
        return len(self.__lstCommands)

    def __next__(self):
        if self.__index >= len(self.__lstCommands):
            self.__index = 0
            raise StopIteration
        else:
            self.__index += 1
            return [self.__lstCommands[self.__index - 1],
                    self.__workFiles.baseFiles,
                    self.__workFiles.sourceFiles[self.__index - 1],
                    self.__workFiles.destinationFiles[self.__index - 1]]

    @property
    def log(self):
        """
        return log enable/disable
        instance variable self.__log
        overrides global variable
        """
        if self.__log is not None:
            return self.__log

        return MKVCommand.classLog()

    @log.setter
    def log(self, value):
        """set instance log variable"""
        if isinstance(value, bool) or value is None:
            self.__log = value

    @property
    def command(self):
        """
        property command produced by mkvtoolnix-gui can be set
        """
        return self.__strShellcommand

    @command.setter
    def command(self, value):
        """Update command through property"""
        if isinstance(value, str):
            self.__reset()
            self._initHelper(value, bRemoveTitle=True)

    @property
    def baseFiles(self):
        """baseFiles"""
        return self.__workFiles.baseFiles

    @property
    def sourceFiles(self):
        """sourceFile"""
        return self.__workFiles.sourceFiles

    @property
    def destinationFiles(self):
        """destinationFile"""
        return self.__workFiles.destinationFiles

    @property
    def template(self):
        """template to construct the commands"""
        return self.__commandTemplate

    @property
    def error(self):
        """error description"""
        return self.__strError

class _WorkFiles:
    """Files read from directories"""

    def __init__(self):

        self.baseFiles = []
        self.sourceFiles = []
        self.destinationFiles = []

    def clear(self):
        """Clear file lists"""

        self.baseFiles = []
        self.sourceFiles = []
        self.destinationFiles = []


def _resolveOverwrite(fileName, strPrefix='new-'):

    fileNameTmp = fileName

    # Check if destination file exist and add prefix if it does
    if fileNameTmp.is_file():

        strSuffix = ""
        n = 1

        while True:
            fileNameTmp = fileNameTmp.parent.joinpath(
                strPrefix
                + fileName.stem
                + strSuffix
                + fileName.suffix
            )

            if fileNameTmp.is_file():
                strSuffix = " ({})".format(n)
                n += 1
            else:
                break
    # video-S01E01.mkv
    return fileNameTmp

def _strPath(value):
    print(str(value))
    return str(value)
